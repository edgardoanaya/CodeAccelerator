//------------------------------------------------------------------------------
// <auto-generated>
//     This code is part of the framework base.
//
//     Manual changes to this file may cause unexpected behavior in your application.
//     Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// <copyright company="SoftwareOne">Copyright(c) 2023 All Rights Reserved.</copyright>
// <author>Santiago Gil Roldán</author>
// <email>mailto:santiago.gil2@softwareone.com</email>
// <summary>Class with extended methods to centralize specific functionalities of each type of object</summary>
namespace SoftwareOne.BaseLine.Core.ExtensionMethods
{
    using System;
    using System.Globalization;
    using System.Reflection;
    using System.Text.RegularExpressions;

    /// <summary>
    /// Class with extended methods to centralize specific functionalities of each type of object.
    /// </summary>
    [AttributeUsage(AttributeTargets.All)]
    public sealed class ValidatedNotNullAttribute : Attribute { }

    /// <summary>
    /// Attribute Extend to hide object properties when exporting to Excel
    /// </summary>
    [AttributeUsage(AttributeTargets.Property)]
    public sealed class ExcelPropertyAttribute : Attribute
    {
        public string Name { private set; get; }
        public int Order { private set; get; }
        public bool Hidden { private set; get; }

        public ExcelPropertyAttribute(string name, int order = 0, bool hidden = false)
        {
            this.Name = name;
            this.Order = order;
            this.Hidden = hidden;
        }
    }

    /// <summary>
    /// Class with extended methods to centralize specific functionalities of each type of object.
    /// </summary>
    public static partial class ExtensionMethods
    {
        /// <summary>
        /// Calculate days, hours and minutes from minutes
        /// </summary>
        /// <param name="minutosTime">Time in minutes</param>
        /// <returns>Days, hours and minutes from minutes of time.</returns>
        public static string[] CalculateTimeFromMinutes(this int minutosTime)
        {
            return CalculateTimeFromHours(minutosTime / 60d);
        }

        /// <summary>
        /// Calculate days, hours and minutes from hours
        /// </summary>
        /// <param name="hoursTime">Time in hours</param>
        /// <returns>Days, hours and minutes from hours of time.</returns>
        public static string[] CalculateTimeFromHours(this double hoursTime)
        {
            int hours = (int)Math.Truncate(hoursTime);
            double decimales = hoursTime - hours;
            TimeSpan tiempo = new TimeSpan(
                                            hours,
                                            Convert.ToInt32(decimales * 60),
                                            0);

            return new string[] { tiempo.Days.PadLeftValue('0'), tiempo.Hours.PadLeftValue('0'), tiempo.Minutes.PadLeftValue('0') };
        }

        /// <summary>
        /// Add parentheses to a text.
        /// </summary>
        /// <param name="s"></param>
        /// <returns></returns>
        public static string Parentesis(this string s)
        {
            // Check for empty string.  
            if (string.IsNullOrEmpty(s))
            {
                return string.Empty;
            }

            return string.Concat("(", s, ")");
        }

        /// <summary>
        /// Add characters to the left.
        /// </summary>
        /// <param name="number">Valor</param>
        /// <param name="padCaracter">Character to add</param>
        /// <returns>Value with added characters</returns>
        public static string PadLeftValue(this int number, char padCaracter)
        {
            return number.PadLeftValue(padCaracter, 2);
        }

        /// <summary>
        /// Add characters to the left.
        /// </summary>
        /// <param name="number">Valor</param>
        /// <param name="padCaracter">Character to add</param>
        /// <param name="totalValue">Tamaño del texto</param>
        /// <returns>Value with added characters</returns>
        public static string PadLeftValue(this int number, char padCaracter, int totalValue)
        {
            return Convert.ToString(number, CultureInfo.InvariantCulture).PadLeft(totalValue, padCaracter);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="s"></param>
        /// <returns></returns>
        public static string FirstCharToUpper(this string s)
        {
            // Check for empty string.  
            if (string.IsNullOrEmpty(s))
            {
                return string.Empty;
            }

            return char.ToUpper(s[0], CultureInfo.CurrentCulture) + s[1..].ToLower(CultureInfo.CurrentCulture);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="lines"></param>
        /// <returns></returns>
        public static string RemoveLineBreaks(this string lines) => lines.ReplaceLineBreaks(string.Empty);

        /// <summary>
        /// 
        /// </summary>
        /// <param name="lines"></param>
        /// <param name="replacement"></param>
        /// <returns></returns>
        public static string ReplaceLineBreaks(this string lines, string replacement) => lines.Replace("\r\n", replacement).Replace("\r", replacement).Replace("\n", replacement);

        /// <summary>
        /// It is in charge of validating if a date type is different from null.
        /// </summary>
        /// <param name="dateTime">Date type</param>
        /// <returns>True or false according to the validation.</returns>
        public static bool IsNotNull(this DateTime? dateTime) => (dateTime != null && dateTime > DateTime.MinValue);

        /// <summary>
        /// BAD PATTERN: Pattern is null or blank, BAD PATTERN: Syntax error
        /// </summary>
        /// <param name="pattern"></param>
        /// <returns></returns>
        public static bool IsRegexPatternValid(this string testPattern)
        {
            bool isValid = true;
            if (testPattern.IsValid())
            {
                try
                {
                    _ = Regex.Match(string.Empty, testPattern);
                }
                catch (ArgumentException)
                {
                    isValid = false;
                }
            }
            else
            {
                isValid = false;
            }

            return (isValid);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="text"></param>
        /// <param name="pattern"></param>
        /// <returns></returns>
        public static bool IsRegexPatternValid(this string text, string pattern)
        {
            bool isValid = false;
            if (pattern.IsRegexPatternValid() && text.IsValid())
            {
                Regex rx = new Regex(pattern, RegexOptions.Compiled | RegexOptions.IgnoreCase);
                return rx.IsMatch(text);
            }

            return (isValid);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="s"></param>
        /// <returns></returns>
        public static bool IsValid([ValidatedNotNull] this string s) => (s.IsNotNull() && s.Trim().Length > 0);

        /// <summary>
        /// 
        /// </summary>
        /// <param name="s"></param>
        /// <returns></returns>
        public static bool IsValid([ValidatedNotNull] this int? s) => (s.HasValue && s.Value > 0);

        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="entity"></param>
        /// <param name="ignoredFields"></param>
        public static void TrimAll<T>(this T entity, params string[] ignoredFields)
        {
            PropertyInfo[] trimProperties = typeof(T)
                                .GetProperties()
                                .Where(c => !ignoredFields.Contains(c.Name) &&
                                          c.CanWrite &&
                                          c.PropertyType == typeof(string))
                                .ToArray();

            foreach (PropertyInfo property in trimProperties)
            {
                string? value = Convert.ToString(property.GetValue(entity, null));
                if (!string.IsNullOrEmpty(value))
                {
                    property.SetValue(entity, value.Trim(), null);
                }
            }
        }
    }
}