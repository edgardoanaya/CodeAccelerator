//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//
//     Manual changes to this file may cause unexpected behavior in your application.
//     Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// <copyright company="SoftwareOne">Copyright(c) 2023 All Rights Reserved.</copyright>
// <author>Jessica Antía Hortúa</author>
// <email>mailto:jessica.antia@softwareone.com</email>
// <summary>Filter that manages the Authorization validations of the project.</summary>
using System.Linq.Expressions;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc.Filters;
using Microsoft.Extensions.Primitives;
using SoftwareOne.BaseLine.Interfaces.ApplicationServices.Facade;
using SoftwareOne.BaseLine.Interfaces.ApplicationServices;
using SoftwareOne.BaseLine.Core.Exceptions;
using SoftwareOne.BaseLine.Core.RequestDto;
using SoftwareOne.BaseLine.EntitiesDto;
using static SoftwareOne.BaseLine.Common.Constant;
using SoftwareOne.BaseLine.ApplicationTexts;

namespace SoftwareOne.BaseLine.Api.Filters
{
    public class AuthorizationFilter : IAsyncActionFilter
    {
        /// <summary>
        /// Constant that contains the URI path length expected from the request.
        /// </summary>
        private const int URI_PATH_LENGTH = 5;
        /// <summary>
        /// Constant that contains the index of the GetPage method.
        /// </summary>
        private const int GET_PAGE_INDEX = 4;

        /// <summary>
        /// Manager for User Account operations.
        /// </summary>
        private readonly IManageUserAccount _manageUserAccount;
        /// <summary>
        /// Facade for AutorizationPermissions operations.
        /// </summary>
        private readonly IAuthorizationPermissions _permissionFacade;
        /// <summary>
        /// Facade for User operations.
        /// </summary>
        private readonly IUser _userFacade;

        /// <summary>
        /// Initializes a new instance of the <see cref="AuthorizationFilter"/> class.
        /// </summary>
        public AuthorizationFilter(IManageUserAccount manageUserAccount, IAuthorizationPermissions permissionFacade, IUser userFacade) {
            _manageUserAccount = manageUserAccount;
            _permissionFacade = permissionFacade;
            _userFacade = userFacade;
        }

        /// <summary>
        /// On action execution for the filter.
        /// </summary>
        public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next)
        {
            bool hasAllowAnonymous = context.ActionDescriptor.EndpointMetadata
                                    .Any(em => em.GetType() == typeof(AllowAnonymousAttribute));

            if (hasAllowAnonymous) {
                await next();
            } else {
                // 1. Gets the token from the header.
                var token = context.HttpContext.Request.Headers[AUTH_HEADER];
                // 2. Validates the token. If null then returns error.
                if (StringValues.IsNullOrEmpty(token)) {
                    throw new SwoUnauthorizedException(ResourceValidations.TokenRequired);
                } 
                else
                {
                    // 1. Get the claim email user from the token.
                    string userId = _manageUserAccount.ValidateSession(token);
                    // 2. Get the role user for the email.
                    EntitiesDto.User user = await _userFacade.GetAsync(x => x.Id == Int32.Parse(userId));
                    // 3. Validate if the user has permission to perform the action.
                    bool isAllowed = await ValidatePermissions(context, user.RoleId);
                    // 4. If the user is not authorized, return the error.
                    if (!isAllowed)
                    {
                        throw new SwoForbiddenException(ResourceValidations.Forbidden);
                    }
                    // 5. If the user is authorized, let it be.
                    await next();
                }
            }
        }

        /// <summary>
        /// Validates if the user has permission to perform the action.
        /// </summary>
        private async Task<bool> ValidatePermissions(ActionExecutingContext context, int roleId)
        {
            // Loads the permissions for the user.
            Expression<Func<Entities.AuthorizationPermissions, bool>> expression = x => x.RoleId == roleId;
            SwoParameterOfQuery<Entities.AuthorizationPermissions> parameterOfList = new SwoParameterOfQuery<Entities.AuthorizationPermissions>(expression);
            ICollection<EntitiesDto.AuthorizationPermissions> authPermissions = await _permissionFacade.ListAllAsync(parameterOfList);
            bool isAllowed = false;
            
            foreach (EntitiesDto.AuthorizationPermissions authPermission in authPermissions) {
                var uriPath = context?.HttpContext?.Request?.Path.Value?.Split('/');
                if (IsUserAccountRequest(uriPath, authPermission)) {
                    var httpMethod = context?.HttpContext.Request.Method;
                    switch (httpMethod)
                    {
                        case "GET":
                            isAllowed = authPermission.PermissionList;
                            break;
                        case "POST":
                            isAllowed = ValidatePostPermissions(uriPath, authPermission);
                            break;
                        case "PUT":
                            isAllowed = authPermission.PermissionUpdate;
                            break;
                        case "DELETE":
                            isAllowed = authPermission.PermissionDelete;
                            break;
                        default:
                            isAllowed = false;
                            break;
                    }
                    if(isAllowed) {
                        break;
                    }
                }
            }
            return isAllowed;
        }

        /// <summary>
        /// Validates if the request is for user account.
        /// </summary>
        private bool IsUserAccountRequest(string[] uriPath, AuthorizationPermissions authPermission)
        {
            var entityRequested = uriPath?.ElementAt(3);
            if (entityRequested != null && (entityRequested.Equals("UserAccount") || authPermission.EntityName == entityRequested))
            {
                return true;
            }
            return false;
        }

        /// <summary>
        /// Validates if the user has permission to perform the POST action.
        /// </summary>
        private bool ValidatePostPermissions(string[] uriPath, AuthorizationPermissions authPermission)
        {
            if (uriPath?.Length >= URI_PATH_LENGTH && uriPath.ElementAt(GET_PAGE_INDEX) == "GetPage") {
                // List
                if (authPermission.PermissionList) {
                    return true;
                }
            }
            else {
                // Create
                if (authPermission.PermissionCreate) {
                    return true;
                }
            }
            return false;
        }
    }
}